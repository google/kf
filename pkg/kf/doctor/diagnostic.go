// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package doctor

import (
	"fmt"
	"io"
	"os"
	"runtime"
	"strings"

	"github.com/fatih/color"
	"github.com/google/kf/pkg/kf/testutil"
)

var (
	failColor = color.New(color.FgHiRed, color.Bold)
	passColor = color.New(color.FgHiGreen, color.Bold)
)

// Assert Diagnostic can be used with our internal testing framework.
var _ testutil.Failable = (*Diagnostic)(nil)

// Diagnostic is a basic test structure that runs and reports on nested tests.
// It's modeled after the testing package.
type Diagnostic struct {
	failed   bool
	output   []byte // Output generated by test or benchmark.
	w        io.Writer
	name     string
	children []*Diagnostic
	parent   *Diagnostic
}

// Run creates and executes a sub-test with the given name.
func (d *Diagnostic) Run(name string, f func(d *Diagnostic)) {
	child := &Diagnostic{
		w:      d.w,
		name:   d.name + "/" + name,
		parent: d,
	}
	d.children = append(d.children, child)

	// run the test in a separate goroutine so Fatal can exit out early.
	fmt.Fprintf(d.w, "=== RUN\t%s\n", child.name)

	finished := make(chan bool)
	go func() {
		defer func() {
			finished <- true
		}()

		f(child)
	}()

	<-finished

	if child.failed {
		d.failed = true
		// We notify of which parent we're printing a log for because they may occur
		// out of order if a child failing causes a parent to dump their logs.
		fmt.Fprintf(d.w, "=== LOG\t%s\n", child.name)
		d.w.Write(child.output)
	}

	if d.parent == nil {
		child.Report()
	}
}

// GatedRun only executes the test function if all prior tests succeeded.
// This is useful as a way to structure top-level tests into groups with a
// logical dependence.
func (d *Diagnostic) GatedRun(name string, f func(d *Diagnostic)) {
	if d.Failed() {
		return
	}

	d.Run(name, f)
}

// Name returns the name of the Diagnostic.
func (d *Diagnostic) Name() string {
	return d.name
}

// Fatal is equivalent to Log followed by FailNow.
func (d *Diagnostic) Fatal(args ...interface{}) {
	d.Log(args...)
	d.FailNow()
}

// Fatalf is equivalent to Logf followed by FailNow.
func (d *Diagnostic) Fatalf(format string, args ...interface{}) {
	d.Logf(format, args...)
	d.FailNow()
}

// Error is equivalent to Log followed by Fail.
func (d *Diagnostic) Error(args ...interface{}) {
	d.Log(fmt.Sprintln(args...))
	d.Fail()
}

// Errorf is equivalent to Logf followed by Fail.
func (d *Diagnostic) Errorf(format string, args ...interface{}) {
	d.Log(fmt.Sprintf(format, args...))
	d.Fail()
}

// Helper is a dummy function to replicate the interface of testing
func (d *Diagnostic) Helper() {
	// noop
}

// FailNow marks the function as having failed and stops its execution by calling
// runtime.Goexit (which then runs all deferred calls in the current goroutine).
// Execution will continue at the parent diagnostic. If FailNow is called on
// the root Diagnostic, the goroutine is not exited.
func (d *Diagnostic) FailNow() {
	d.failed = true

	if d.parent != nil {
		runtime.Goexit()
	}
}

// Fail marks the function as having failed.
func (d *Diagnostic) Fail() {
	d.failed = true
}

// Log formats its arguments using default formatting, analogous to Println,
// and records the text in the error log.
func (d *Diagnostic) Log(args ...interface{}) {
	d.log(fmt.Sprintln(args...))
}

// Logf formats its arguments according to the format, analogous to Printf, and
// records the text in the error log.
func (d *Diagnostic) Logf(format string, args ...interface{}) {
	d.log(fmt.Sprintf(format, args...))
}

func (d *Diagnostic) log(s string) {
	d.output = append(d.output, s...)

	if !strings.HasSuffix(s, "\n") {
		d.output = append(d.output, '\n')
	}
}

// Report creates a detailed testing style report for the execution.
func (d *Diagnostic) Report() {
	d.reportIndent(0)
}

func (d *Diagnostic) reportIndent(indent int) {
	prefix := strings.Repeat("    ", indent)

	passfail := passColor.Sprint("PASS")
	if d.Failed() {
		passfail = failColor.Sprint("FAIL")
	}

	fmt.Fprintf(d.w, "%s--- %s: %s", prefix, passfail, d.name)
	fmt.Fprintln(d.w)

	for _, child := range d.children {
		child.reportIndent(indent + 1)
	}
}

// Failed reports whether the function has failed.
func (d *Diagnostic) Failed() bool {
	return d.failed
}

// NewDefaultDiagnostic creates a diagnostic with the root name of "doctor"
// that reports to stdout.
func NewDefaultDiagnostic() *Diagnostic {
	return NewDiagnostic("doctor", os.Stdout)
}

// NewDiagnostic creates a new diagnostic with the given name that reports to
// the given writer.
func NewDiagnostic(name string, w io.Writer) *Diagnostic {
	return &Diagnostic{name: name, w: w}
}

// Diagnosable provides a high-level way to indicate a resource can be diagnosed.
type Diagnosable interface {
	Diagnose(d *Diagnostic)
}
